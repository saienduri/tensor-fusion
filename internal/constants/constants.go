package constants

import (
	"os"
	"time"

	"k8s.io/utils/ptr"
)

const (
	NvidiaGPUKey = "nvidia.com/gpu"
	AmdGPUKey    = "amd.com/gpu"

	// NVIDIA GPU driver upgrade state label
	NvidiaGPUDriverUpgradeStateLabel = "nvidia.com/gpu-driver-upgrade-state"
	NvidiaGPUDriverUpgradeStateDone  = "upgrade-done"
)

var (
	PendingRequeueDuration     = time.Second * 3
	StatusCheckInterval        = time.Second * 6
	GracefulPeriodSeconds      = ptr.To(int64(5))
	UnschedQueueBufferDuration = 10 * time.Second
)

var (
	// Domain is the domain prefix used for all tensor-fusion.ai related annotations and finalizers
	// Change env var for enterprise's custom domain
	DomainPrefix = func() string {
		domainPrefix := os.Getenv("TENSOR_FUSION_CUSTOM_DOMAIN_PREFIX")
		if domainPrefix == "" {
			return "tensor-fusion"
		}
		return domainPrefix
	}()

	DomainSuffix = func() string {
		domainSuffix := os.Getenv("TENSOR_FUSION_CUSTOM_DOMAIN_SUFFIX")
		if domainSuffix == "" {
			return "ai"
		}
		return domainSuffix
	}()

	Domain = DomainPrefix + "." + DomainSuffix

	// Finalizer constants
	FinalizerSuffix = "finalizer"
	Finalizer       = Domain + "/" + FinalizerSuffix

	SchedulerName = DomainPrefix + "-scheduler"

	LabelKeyOwner           = Domain + "/managed-by"
	LabelKeyClusterOwner    = Domain + "/cluster"
	LabelKeyNodeClass       = Domain + "/node-class"
	LabelKeyPodTemplateHash = Domain + "/pod-template-hash"
	LabelNodeSelectorHash   = Domain + "/node-selector-hash"
	LabelComponent          = Domain + "/component"
	// used by TF connection, for matching the related connections when worker Pod state changed
	LabelWorkerName = Domain + "/worker-name"

	ComponentClient        = "client"
	ComponentWorker        = "worker"
	ComponentHypervisor    = "hypervisor"
	ComponentNodeDiscovery = "node-discovery"
	ComponentOperator      = "operator"
	ComponentDriverProbe   = "driver-probe"

	GPUNodePoolIdentifierLabelPrefix = Domain + "/pool-"
	GPUNodePoolIdentifierLabelFormat = Domain + "/pool-%s"
	NodeDeletionMark                 = Domain + "/should-delete"

	TensorFusionEnabledLabelKey = Domain + "/enabled"
	InitialGPUNodeSelector      = "nvidia.com/gpu.present=true"

	LastSyncTimeAnnotationKey = Domain + "/last-sync"
	WorkloadKey               = Domain + "/workload"

	GpuPoolKey = Domain + "/gpupool"

	// Annotation key constants
	GpuCountAnnotation = Domain + "/gpu-count"
	// Specify which GPU index to use, when multiple GPUs are available, comma separated list of GPU indices
	GpuIndicesAnnotation = Domain + "/gpu-indices"
	// Specify which GPU/NPU/XPU vendor to use, default to any vendors in cluster
	GpuVendorAnnotation     = Domain + "/vendor"
	TFLOPSRequestAnnotation = Domain + "/tflops-request"
	VRAMRequestAnnotation   = Domain + "/vram-request"
	TFLOPSLimitAnnotation   = Domain + "/tflops-limit"
	VRAMLimitAnnotation     = Domain + "/vram-limit"

	// StreamMultiProcessor/AICore percentage, alternative to TFLOPs request and limit, NOT Recommended way
	// NOTE: using percent will cause namespace level quota check impossible, will bypass all quota check
	// thus, percent should only be used when tenant quota is not needed, and only one type of GPU in cluster
	ComputeRequestAnnotation = Domain + "/compute-percent-request"
	ComputeLimitAnnotation   = Domain + "/compute-percent-limit"

	WorkloadProfileAnnotation = Domain + "/workload-profile"
	InjectContainerAnnotation = Domain + "/inject-container"
	IsLocalGPUAnnotation      = Domain + "/is-local-gpu"
	QoSLevelAnnotation        = Domain + "/qos"
	EmbeddedWorkerAnnotation  = Domain + "/embedded-worker"
	DedicatedWorkerAnnotation = Domain + "/dedicated-worker"
	SidecarWorkerAnnotation   = Domain + "/sidecar-worker"
	// How to isolate resources, default to `soft`` mode, could be `shared` or `hard` or `partitioned`
	IsolationModeAnnotation = Domain + "/isolation"
	// GPUModelAnnotation specifies the required GPU model (e.g., "A100", "H100")
	GPUModelAnnotation = Domain + "/gpu-model"
	// GPU ID list is assigned by scheduler, should not specified by user
	GPUDeviceIDsAnnotation = Domain + "/gpu-ids"
	// User can specify the partition name to designate the partition template to use, e.g. 1g.20gb+me
	// TODO: parse and pre-set in scheduler plugin to avoid find matched partition.
	PartitionNameAnnotation = Domain + "/partition"
	// PartitionTemplateIDAnnotation is the partition UUID assigned to a pod in partitioned mode
	// This is read by accelerator.c to mock slice GPU like MIG does
	PartitionTemplateIDAnnotation     = Domain + "/partition-id"
	DedicatedGPUAnnotation            = Domain + "/dedicated-gpu"
	SetPendingOwnedWorkloadAnnotation = Domain + "/pending-owned-workload"
	PricingAnnotation                 = Domain + "/hourly-pricing"
	// In remote vGPU mode, selected workload is set by user with /workload annotation or generated by system
	SelectedWorkloadAnnotation = Domain + "/selected-workload"
	// Additional worker pod template is set by user with /worker-pod-template annotation
	WorkerPodTemplateAnnotation = Domain + "/worker-pod-template"

	// Pod index annotation for Device Plugin communication (1-128)
	// When it's in annotation, use this string, when it's in resource limits, use it as prefix
	PodIndexAnnotation = Domain + "/index"
	PodIndexDelimiter  = "_"

	WorkloadModeAnnotation = Domain + "/workload-mode"
	WorkloadModeDynamic    = "dynamic"
	WorkloadModeFixed      = "fixed"

	// Annotations for killer switch: disable features
	// ['gpu-opt', 'mem-manager', 'gpu-limiter']
	DisableFeaturesAnnotation = Domain + "/disable-features"
	BuiltInFeaturesGpuOpt     = "gpu-opt"
	BuiltInFeaturesGpuLimiter = "gpu-limiter"
	BuiltInFeaturesMemManager = "mem-manager"
	// For debug purpose only of Remote vGPU, disable start worker to manual start with ad-hoc command inside Pod
	BuiltInFeatureStartWorker = "start-worker"

	GenHostPortLabel        = Domain + "/host-port"
	GenHostPortLabelValue   = "auto"
	GenHostPortNameLabel    = Domain + "/port-name"
	GenPortNumberAnnotation = Domain + "/port-number"

	// Enable autoscale, configure in workload or simply enable default rule with annotation
	AutoScaleResourcesAnnotation = Domain + "/autoscale"
	// Target resource to autoscale, such as "compute", "vram", or "all" by default
	AutoScaleTargetResourceAnnotation = Domain + "/autoscale-target"

	GpuReleasedAnnotation = Domain + "/gpu-released"

	TensorFusionPodCounterKeyAnnotation = Domain + "/pod-counter-key"
	TensorFusionPodCountAnnotation      = Domain + "/tf-pod-count"
	TensorFusionWorkerSuffix            = "-tf"
	NodeUsedByTaintKey                  = Domain + "/used-by"

	// For grey release
	TensorFusionEnabledReplicasAnnotation = Domain + "/enabled-replicas"
	TensorFusionDefaultPoolKeyAnnotation  = Domain + "/is-default-pool"
	// Eviction protection annotation for controlling pod eviction timing
	EvictionProtectionAnnotation = Domain + "/eviction-protection"

	// Gang Scheduling annotations
	// GangMinMembersAnnotation specifies minimum number of pods that must be scheduled together
	// When > 0, gang scheduling is enabled for this workload
	GangMinMembersAnnotation = Domain + "/gang-min-members"
	// GangTimeoutAnnotation specifies the timeout for waiting all gang members
	// If not set or set to "0", wait indefinitely until resources are available
	GangTimeoutAnnotation = Domain + "/gang-timeout"

	NamespaceDefaultVal = "tensor-fusion-sys"

	KubernetesHostNameLabel = "kubernetes.io/hostname"
	KarpenterExpansionLabel = Domain + "/expansion-source"

	HypervisorServiceAccountName = "tensor-fusion-hypervisor-sa"

	TSDBVersionConfigMap = "tensor-fusion-tsdb-version"
)

const (
	QoSLevelLow      = "low"
	QoSLevelMedium   = "medium"
	QoSLevelHigh     = "high"
	QoSLevelCritical = "critical"
)

// for avoid golang lint issues
const (
	TrueStringValue  = "true"
	FalseStringValue = "false"
)

const (
	ConditionStatusTypeReady           = "Ready"
	ConditionStatusTypeGPUScheduled    = "GPUScheduled"
	ConditionStatusTypeConnectionReady = "ConnectionReady"
	ConditionStatusTypeNodeProvisioned = "NodeProvisioned"
	ConditionStatusTypePoolReady       = "PoolReady"

	ConditionStatusTypeGPUPool               = "GPUPoolReady"
	ConditionStatusTypeTimeSeriesDatabase    = "TimeSeriesDatabaseReady"
	ConditionStatusTypeCloudVendorConnection = "CloudVendorConnectionReady"

	ConditionStatusTypeRecommendationProvided = "RecommendationProvided"
	ConditionStatusTypeResourceUpdate         = "ResourceUpdate"
)

const (
	PhaseUnknown    = "Unknown"
	PhasePending    = "Pending"
	PhaseUpdating   = "Updating"
	PhaseScheduling = "Scheduling"
	PhaseMigrating  = "Migrating"
	PhaseDestroying = "Destroying"

	PhaseRunning   = "Running"
	PhaseSucceeded = "Succeeded"
	PhaseFailed    = "Failed"
)

var (
	// No disrupt label, similar to Karpenter, avoid TFConnection/Worker/GPUNode to be moved to another node or destroying node.
	// Refer: https://karpenter.sh/docs/concepts/disruption/
	SchedulingDoNotDisruptLabel = Domain + "/do-not-disrupt"
)

const (
	GPUNodeOSLinux   = "linux"
	GPUNodeOSWindows = "windows"
	GPUNodeOSMacOS   = "macos"
)

// To match GPUNode with K8S node, when creating from cloud vendor, must set a label from cloud-init userdata
var (
	ProvisionerLabelKey        = Domain + "/node-provisioner"
	ProvisionerMissingLabel    = Domain + "/orphan"
	ProvisionerNamePlaceholder = "__GPU_NODE_RESOURCE_NAME__"
)
var (
	TFDataPath                       = "/run/tensor-fusion"
	TFDataPathWorkerExpr             = "shm/$(POD_NAMESPACE)/$(POD_NAME)"
	DataVolumeName                   = "tf-data"
	TransportShmVolumeName           = "tf-transport-shm"
	TransportShmPath                 = "/dev/shm"
	TensorFusionPoolManualCompaction = Domain + "/manual-compaction"
	TensorFusionSystemName           = DomainPrefix

	LeaderInfoConfigMapName        = "tensor-fusion-operator-leader-info"
	LeaderInfoConfigMapLeaderIPKey = "leader-ip"
	AcceleratorLabelVendor         = Domain + "/hardware-vendor"
)

const ShortUUIDAlphabet = "123456789abcdefghijkmnopqrstuvwxy"
const SpotInstanceAssumedDiscountRatio = 0.3
const MountShmSubcommand = "mount-shm"

const (
	LowFrequencyObjFailureInitialDelay        = 300 * time.Millisecond
	LowFrequencyObjFailureMaxDelay            = 1000 * time.Second
	LowFrequencyObjFailureMaxRPS              = 1
	LowFrequencyObjFailureMaxBurst            = 1
	LowFrequencyObjFailureConcurrentReconcile = 5
)

const (
	TelemetryEndpointEnvVar   = "TELEMETRY_ENDPOINT"
	TelemetryPublicKeyEnvVar  = "TELEMETRY_PUBLIC_KEY"
	DefaultTelemetryEndpoint  = "https://us.i.posthog.com"
	DefaultTelemetryPublicKey = "phc_qd1mhrtK35PpXx0bYQAYcscTJNnno73mC9qMwioTCi7"
)

const GiBToBytes = 1024 * 1024 * 1024

const AuthorizationHeader = "Authorization"
const ExtraVerificationInfoPodIDKey = "authentication.kubernetes.io/pod-uid"

// External connection constants
const (
	ExternalConnectionAPIKeyHeader  = "X-API-Key"
	ExternalConnectionSecretName      = "tensor-fusion-api-keys"
	ExternalConnectionSecretDataKey   = "keys.json"
	ExternalConnectionSecretNamespace = "tensor-fusion"

	// Default TTL bounds for external connections (in seconds)
	ExternalConnectionMinTTL     = 60    // 1 minute
	ExternalConnectionMaxTTL     = 86400 // 24 hours
	ExternalConnectionDefaultTTL = 3600  // 1 hour
)

// External connection label keys (depend on Domain variable)
var (
	ExternalConnectionLabelKey    = Domain + "/external-client"
	ExternalConnectionClientIDKey = Domain + "/client-id"
	// NodePublicIPAnnotation is used to specify a node's public IP for external connections
	NodePublicIPAnnotation = Domain + "/public-ip"
)

const SchedulerSimulationKey = "simulate-schedule"

const MobileGpuClockSpeedMultiplier = 0.75
const DefaultEvictionProtectionPriceRatio = 1.2
const NodeCriticalPriorityClassName = "system-node-critical"
const KarpenterNodeClaimKind = "NodeClaim"
const KarpenterNodePoolKind = "NodePool"

const (
	// 16x8 dummy index device at max
	// tensor-fusion.ai/index_0: 1 to tensor-fusion.ai/index_f: 8
	IndexKeyLength = 16
	IndexModLength = 8
)
